#include "message_store.h"
#include "schema.h"
#include "database_gossip.h"
#include "packages/utils/logger.h"
#include <sqlite3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/sha.h>

// Include message protobuf header when available (generated by CMake)
#include "message.pb-c.h"
#include "api.pb-c.h"

// SQL statements for message store (re-using defines if needed, but here we specify them for self-containment)
#define MESSAGE_CREATE_TABLE_USER_MESSAGES \
    "CREATE TABLE IF NOT EXISTS user_messages (" \
    "id INTEGER PRIMARY KEY AUTOINCREMENT," \
    "version INTEGER NOT NULL," \
    "timestamp INTEGER NOT NULL," \
    "sender_pubkey BLOB NOT NULL," \
    "recipient_pubkey BLOB NOT NULL," \
    "group_id BLOB," \
    "payload_nonce BLOB NOT NULL," \
    "ephemeral_pubkey BLOB NOT NULL," \
    "encrypted_payload BLOB NOT NULL," \
    "signature BLOB NOT NULL," \
    "expires_at INTEGER NOT NULL," \
    "created_at INTEGER NOT NULL DEFAULT (strftime('%s','now'))" \
    ");"

#define MESSAGE_CREATE_TABLE_MESSAGE_RECIPIENTS \
    "CREATE TABLE IF NOT EXISTS message_recipients (" \
    "message_id INTEGER NOT NULL," \
    "recipient_pubkey BLOB NOT NULL," \
    "key_nonce BLOB NOT NULL," \
    "wrapped_key BLOB NOT NULL," \
    "PRIMARY KEY (message_id, recipient_pubkey)," \
    "FOREIGN KEY (message_id) REFERENCES user_messages(id) ON DELETE CASCADE" \
    ");"

// Message store indexes
#define MESSAGE_CREATE_INDEX_TIMESTAMP \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_timestamp ON user_messages(timestamp DESC);"

#define MESSAGE_CREATE_INDEX_SENDER \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_sender ON user_messages(sender_pubkey, timestamp DESC);"

#define MESSAGE_CREATE_INDEX_RECIPIENT \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_recipient ON user_messages(recipient_pubkey, timestamp DESC);"

#define MESSAGE_CREATE_INDEX_CONVERSATION \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_conversation ON user_messages(sender_pubkey, recipient_pubkey, timestamp DESC);"

#define MESSAGE_CREATE_INDEX_GROUP \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_group ON user_messages(group_id, timestamp DESC) WHERE group_id IS NOT NULL;"

#define MESSAGE_CREATE_INDEX_EXPIRES \
    "CREATE INDEX IF NOT EXISTS idx_user_messages_expires ON user_messages(expires_at);"

#define MESSAGE_CREATE_INDEX_RECIPIENTS_RECIPIENT \
    "CREATE INDEX IF NOT EXISTS idx_message_recipients_recipient ON message_recipients(recipient_pubkey);"

int message_store_init(void) {
    if (!db_is_initialized()) {
        logger_error("message_store", "database not initialized");
        return -1;
    }

    sqlite3* db = db_get_handle();
    if (!db) {
        logger_error("message_store", "failed to get database handle");
        return -1;
    }

    char* error_msg = NULL;
    int rc;

    // Create user_messages table
    rc = sqlite3_exec(db, MESSAGE_CREATE_TABLE_USER_MESSAGES, NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("message_store", "failed to create user_messages table: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Create message_recipients table
    rc = sqlite3_exec(db, MESSAGE_CREATE_TABLE_MESSAGE_RECIPIENTS, NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("message_store", "failed to create message_recipients table: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Create indexes
    const char* index_statements[] = {
        MESSAGE_CREATE_INDEX_TIMESTAMP,
        MESSAGE_CREATE_INDEX_SENDER,
        MESSAGE_CREATE_INDEX_RECIPIENT,
        MESSAGE_CREATE_INDEX_CONVERSATION,
        MESSAGE_CREATE_INDEX_GROUP,
        MESSAGE_CREATE_INDEX_EXPIRES,
        MESSAGE_CREATE_INDEX_RECIPIENTS_RECIPIENT,
        NULL
    };

    for (int i = 0; index_statements[i] != NULL; ++i) {
        rc = sqlite3_exec(db, index_statements[i], NULL, NULL, &error_msg);
        if (rc != SQLITE_OK) {
            logger_error("message_store", "failed to create index: %s", error_msg);
            sqlite3_free(error_msg);
            return -1;
        }
    }

    logger_info("message_store", "message store schema initialized successfully");
    return 0;
}

// Compute SHA256 digest of serialized Message for deduplication
int message_store_compute_digest(const Tinyweb__Message* message, unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE]) {
    if (!message) return -1;
    
    // Serialize message to compute digest
    size_t len = tinyweb__message__get_packed_size((Tinyweb__Message*)message);
    unsigned char* buf = malloc(len);
    if (!buf) return -1;
    
    tinyweb__message__pack((Tinyweb__Message*)message, buf);
    SHA256(buf, len, digest);
    free(buf);
    
    return 0;
}

int message_store_save(const Tinyweb__Message* message, uint64_t expires_at) {
    if (!db_is_initialized() || !message || !message->header) {
        logger_error("message_store", "message_store_save: invalid arguments");
        return -1;
    }
    
    sqlite3* db = db_get_handle();
    if (!db) {
        logger_error("message_store", "message_store_save: failed to get database handle");
        return -1;
    }
    
    const Tinyweb__MessageHeader* hdr = message->header;
    
    // Validate required fields
    if (hdr->sender_pubkey.len != PUBKEY_SIZE) {
        logger_error("message_store", "message_store_save: invalid sender_pubkey length");
        return -1;
    }
    if (hdr->n_recipients_pubkey == 0) {
        logger_error("message_store", "message_store_save: no recipients");
        return -1;
    }
    if (!message->payload_nonce.data || message->payload_nonce.len != 24) {
        logger_error("message_store", "message_store_save: invalid payload_nonce");
        return -1;
    }
    if (!message->ephemeral_pubkey.data || message->ephemeral_pubkey.len != PUBKEY_SIZE) {
        logger_error("message_store", "message_store_save: invalid ephemeral_pubkey");
        return -1;
    }
    if (!message->payload_ciphertext.data || message->payload_ciphertext.len == 0) {
        logger_error("message_store", "message_store_save: invalid payload_ciphertext");
        return -1;
    }
    if (!message->signature.data || message->signature.len != 64) {
        logger_error("message_store", "message_store_save: invalid signature");
        return -1;
    }
    
    char* error_msg = NULL;
    int rc = sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("message_store", "failed to start transaction: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Insert into user_messages table
    const char* sql =
        "INSERT INTO user_messages(version, timestamp, sender_pubkey, recipient_pubkey, "
        "group_id, payload_nonce, ephemeral_pubkey, encrypted_payload, signature, expires_at) "
        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    sqlite3_stmt* stmt = NULL;
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("message_store", "message_store_save: failed to prepare statement: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    sqlite3_bind_int(stmt, 1, (int)hdr->version);
    sqlite3_bind_int64(stmt, 2, (sqlite3_int64)hdr->timestamp);
    sqlite3_bind_blob(stmt, 3, hdr->sender_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    
    // Primary recipient is first in recipients_pubkey array
    if (hdr->recipients_pubkey[0].len != PUBKEY_SIZE) {
        sqlite3_finalize(stmt);
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("message_store", "message_store_save: invalid primary recipient_pubkey");
        return -1;
    }
    sqlite3_bind_blob(stmt, 4, hdr->recipients_pubkey[0].data, PUBKEY_SIZE, SQLITE_STATIC);
    
    if (hdr->group_id.data && hdr->group_id.len > 0) {
        sqlite3_bind_blob(stmt, 5, hdr->group_id.data, (int)hdr->group_id.len, SQLITE_STATIC);
    } else {
        sqlite3_bind_null(stmt, 5);
    }
    
    sqlite3_bind_blob(stmt, 6, message->payload_nonce.data, 24, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 7, message->ephemeral_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 8, message->payload_ciphertext.data, (int)message->payload_ciphertext.len, SQLITE_TRANSIENT);
    sqlite3_bind_blob(stmt, 9, message->signature.data, 64, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 10, (sqlite3_int64)expires_at);
    
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    if (rc != SQLITE_DONE) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("message_store", "message_store_save: failed to insert message: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    int64_t message_id = sqlite3_last_insert_rowid(db);
    
    if (message->n_keywraps > 0) {
        const char* recipient_sql =
            "INSERT INTO message_recipients(message_id, recipient_pubkey, key_nonce, wrapped_key) "
            "VALUES (?, ?, ?, ?);";
        
        sqlite3_stmt* recipient_stmt = NULL;
        if (sqlite3_prepare_v2(db, recipient_sql, -1, &recipient_stmt, NULL) != SQLITE_OK) {
            sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
            return -1;
        }

        for (size_t i = 0; i < message->n_keywraps; ++i) {
            const Tinyweb__MessageRecipientKeyWrap* wrap = message->keywraps[i];
            if (!wrap || wrap->recipient_pubkey.len != PUBKEY_SIZE) continue;
            
            sqlite3_reset(recipient_stmt);
            sqlite3_bind_int64(recipient_stmt, 1, message_id);
            sqlite3_bind_blob(recipient_stmt, 2, wrap->recipient_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
            sqlite3_bind_blob(recipient_stmt, 3, wrap->key_nonce.data, 24, SQLITE_STATIC);
            sqlite3_bind_blob(recipient_stmt, 4, wrap->wrapped_key.data, (int)wrap->wrapped_key.len, SQLITE_STATIC);
            
            rc = sqlite3_step(recipient_stmt);
            if (rc != SQLITE_DONE) {
                logger_error("message_store", "failed to insert recipient %zu", i);
            }
        }
        sqlite3_finalize(recipient_stmt);
    }
    
    sqlite3_exec(db, "COMMIT;", NULL, NULL, NULL);
    return 0;
}

int message_store_has_seen(const unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE], int* is_seen) {
    return gossip_store_has_seen(digest, is_seen);
}

int message_store_mark_seen(const unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE], uint64_t expires_at) {
    return gossip_store_mark_seen(digest, expires_at);
}

static Tinyweb__Message* reconstruct_message_from_db(
    int64_t id,
    uint32_t version, uint64_t timestamp,
    const unsigned char* sender, size_t sender_len,
    const unsigned char* recipient, size_t recipient_len,
    const unsigned char* group_id, size_t group_id_len,
    const unsigned char* payload_nonce, size_t payload_nonce_len,
    const unsigned char* ephemeral_pubkey, size_t ephemeral_pubkey_len,
    const unsigned char* encrypted_payload, size_t encrypted_payload_len,
    const unsigned char* signature, size_t signature_len,
    sqlite3* db) {
    (void)recipient; (void)recipient_len;
    
    if (sender_len != PUBKEY_SIZE ||
        payload_nonce_len != 24 || ephemeral_pubkey_len != PUBKEY_SIZE || signature_len != 64) {
        return NULL;
    }
    
    Tinyweb__Message* msg = calloc(1, sizeof(Tinyweb__Message));
    if (!msg) return NULL;
    tinyweb__message__init(msg);
    
    Tinyweb__MessageHeader* hdr = calloc(1, sizeof(Tinyweb__MessageHeader));
    if (!hdr) {
        free(msg);
        return NULL;
    }
    tinyweb__message_header__init(hdr);
    msg->header = hdr;
    
    hdr->version = version;
    hdr->timestamp = timestamp;
    
    hdr->sender_pubkey.len = PUBKEY_SIZE;
    hdr->sender_pubkey.data = malloc(PUBKEY_SIZE);
    if (!hdr->sender_pubkey.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
    memcpy(hdr->sender_pubkey.data, sender, PUBKEY_SIZE);
    
    if (group_id && group_id_len > 0) {
        hdr->group_id.len = group_id_len;
        hdr->group_id.data = malloc(group_id_len);
        if (!hdr->group_id.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
        memcpy(hdr->group_id.data, group_id, group_id_len);
    }
    
    const char* recipient_sql = 
        "SELECT recipient_pubkey, key_nonce, wrapped_key FROM message_recipients "
        "WHERE message_id = ? ORDER BY recipient_pubkey;";
    sqlite3_stmt* recipient_stmt = NULL;
    int rc = sqlite3_prepare_v2(db, recipient_sql, -1, &recipient_stmt, NULL);
    
    if (rc == SQLITE_OK) {
        sqlite3_bind_int64(recipient_stmt, 1, id);
        size_t count = 0;
        while (sqlite3_step(recipient_stmt) == SQLITE_ROW) count++;
        sqlite3_reset(recipient_stmt);
        
        if (count > 0) {
            hdr->n_recipients_pubkey = count;
            hdr->recipients_pubkey = calloc(count, sizeof(ProtobufCBinaryData));
            msg->n_keywraps = count;
            msg->keywraps = calloc(count, sizeof(Tinyweb__MessageRecipientKeyWrap*));
            
            if (!hdr->recipients_pubkey || !msg->keywraps) {
                sqlite3_finalize(recipient_stmt);
                tinyweb__message__free_unpacked(msg, NULL);
                return NULL;
            }
            
            size_t idx = 0;
            while (sqlite3_step(recipient_stmt) == SQLITE_ROW && idx < count) {
                const void* rec_pk = sqlite3_column_blob(recipient_stmt, 0);
                hdr->recipients_pubkey[idx].len = PUBKEY_SIZE;
                hdr->recipients_pubkey[idx].data = malloc(PUBKEY_SIZE);
                if (!hdr->recipients_pubkey[idx].data) { sqlite3_finalize(recipient_stmt); tinyweb__message__free_unpacked(msg, NULL); return NULL; }
                memcpy(hdr->recipients_pubkey[idx].data, rec_pk, PUBKEY_SIZE);
                
                Tinyweb__MessageRecipientKeyWrap* wrap = calloc(1, sizeof(Tinyweb__MessageRecipientKeyWrap));
                if (wrap) {
                    tinyweb__message_recipient_key_wrap__init(wrap);
                    wrap->recipient_pubkey.len = PUBKEY_SIZE;
                    wrap->recipient_pubkey.data = malloc(PUBKEY_SIZE);
                    const void* nonce = sqlite3_column_blob(recipient_stmt, 1);
                    wrap->key_nonce.len = 24;
                    wrap->key_nonce.data = malloc(24);
                    const void* key = sqlite3_column_blob(recipient_stmt, 2);
                    int klen = sqlite3_column_bytes(recipient_stmt, 2);
                    wrap->wrapped_key.len = klen;
                    wrap->wrapped_key.data = malloc(klen);
                    
                    if (!wrap->recipient_pubkey.data || !wrap->key_nonce.data || !wrap->wrapped_key.data) {
                        if (wrap->recipient_pubkey.data) free(wrap->recipient_pubkey.data);
                        if (wrap->key_nonce.data) free(wrap->key_nonce.data);
                        if (wrap->wrapped_key.data) free(wrap->wrapped_key.data);
                        free(wrap);
                        sqlite3_finalize(recipient_stmt);
                        tinyweb__message__free_unpacked(msg, NULL);
                        return NULL;
                    }
                    
                    memcpy(wrap->recipient_pubkey.data, rec_pk, PUBKEY_SIZE);
                    memcpy(wrap->key_nonce.data, nonce, 24);
                    memcpy(wrap->wrapped_key.data, key, klen);
                    msg->keywraps[idx] = wrap;
                } else {
                    sqlite3_finalize(recipient_stmt);
                    tinyweb__message__free_unpacked(msg, NULL);
                    return NULL;
                }
                idx++;
            }
        }
        sqlite3_finalize(recipient_stmt);
    }
    
    msg->payload_nonce.len = 24;
    msg->payload_nonce.data = malloc(24);
    if (!msg->payload_nonce.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
    memcpy(msg->payload_nonce.data, payload_nonce, 24);
    
    msg->ephemeral_pubkey.len = PUBKEY_SIZE;
    msg->ephemeral_pubkey.data = malloc(PUBKEY_SIZE);
    if (!msg->ephemeral_pubkey.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
    memcpy(msg->ephemeral_pubkey.data, ephemeral_pubkey, PUBKEY_SIZE);
    
    msg->payload_ciphertext.len = encrypted_payload_len;
    msg->payload_ciphertext.data = malloc(encrypted_payload_len);
    if (!msg->payload_ciphertext.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
    memcpy(msg->payload_ciphertext.data, encrypted_payload, encrypted_payload_len);
    
    msg->signature.len = 64;
    msg->signature.data = malloc(64);
    if (!msg->signature.data) { tinyweb__message__free_unpacked(msg, NULL); return NULL; }
    memcpy(msg->signature.data, signature, 64);
    
    return msg;
}

int message_store_fetch_recent(const unsigned char user_pubkey[PUBKEY_SIZE],
                               uint32_t limit,
                               Tinyweb__Message*** out,
                               size_t* count) {
    if (!user_pubkey || !out || !count || !db_is_initialized()) return -1;
    *out = NULL; *count = 0;
    sqlite3* db = db_get_handle(); if (!db) return -1;
    
    const char* sql =
        "SELECT id, version, timestamp, sender_pubkey, recipient_pubkey, group_id, "
        "payload_nonce, ephemeral_pubkey, encrypted_payload, signature "
        "FROM user_messages "
        "WHERE sender_pubkey = ? "
        "   OR recipient_pubkey = ? "
        "   OR id IN (SELECT message_id FROM message_recipients WHERE recipient_pubkey = ?) "
        "ORDER BY timestamp DESC LIMIT ?;";
    
    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    
    sqlite3_bind_blob(stmt, 1, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 2, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 3, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 4, (int)limit);
    
    size_t rows = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW) rows++;
    sqlite3_reset(stmt);
    
    if (rows == 0) { sqlite3_finalize(stmt); return 0; }
    
    Tinyweb__Message** messages = calloc(rows, sizeof(Tinyweb__Message*));
    if (!messages) { sqlite3_finalize(stmt); return -1; }
    
    size_t idx = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW && idx < rows) {
        messages[idx] = reconstruct_message_from_db(
            sqlite3_column_int64(stmt, 0), (uint32_t)sqlite3_column_int(stmt, 1),
            (uint64_t)sqlite3_column_int64(stmt, 2),
            sqlite3_column_blob(stmt, 3), sqlite3_column_bytes(stmt, 3),
            sqlite3_column_blob(stmt, 4), sqlite3_column_bytes(stmt, 4),
            sqlite3_column_blob(stmt, 5), sqlite3_column_bytes(stmt, 5),
            sqlite3_column_blob(stmt, 6), sqlite3_column_bytes(stmt, 6),
            sqlite3_column_blob(stmt, 7), sqlite3_column_bytes(stmt, 7),
            sqlite3_column_blob(stmt, 8), sqlite3_column_bytes(stmt, 8),
            sqlite3_column_blob(stmt, 9), sqlite3_column_bytes(stmt, 9),
            db);
        if (messages[idx]) idx++;
    }
    sqlite3_finalize(stmt);
    *out = messages; *count = idx;
    return 0;
}

int message_store_fetch_conversation(const unsigned char user1_pubkey[PUBKEY_SIZE],
                                     const unsigned char user2_pubkey[PUBKEY_SIZE],
                                     uint32_t limit,
                                     Tinyweb__Message*** out,
                                     size_t* count) {
    if (!user1_pubkey || !user2_pubkey || !out || !count || !db_is_initialized()) return -1;
    *out = NULL; *count = 0;
    sqlite3* db = db_get_handle(); if (!db) return -1;
    
    // Query messages where:
    // 1. Direct match: (user1 sends to user2) OR (user2 sends to user1)
    // 2. Multi-recipient: message has both users involved (check message_recipients table)
    //    - user1 is sender and user2 is in recipients, OR
    //    - user2 is sender and user1 is in recipients
    const char* sql =
        "SELECT DISTINCT m.id, m.version, m.timestamp, m.sender_pubkey, m.recipient_pubkey, m.group_id, "
        "m.payload_nonce, m.ephemeral_pubkey, m.encrypted_payload, m.signature "
        "FROM user_messages m "
        "LEFT JOIN message_recipients mr ON m.id = mr.message_id "
        "WHERE ((m.sender_pubkey = ? AND m.recipient_pubkey = ?) "
        "    OR (m.sender_pubkey = ? AND m.recipient_pubkey = ?)) "
        "   OR ((m.sender_pubkey = ? AND mr.recipient_pubkey = ?) "
        "    OR (m.sender_pubkey = ? AND mr.recipient_pubkey = ?)) "
        "ORDER BY m.timestamp DESC LIMIT ?;";
    
    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) return -1;
    
    sqlite3_bind_blob(stmt, 1, user1_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 2, user2_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 3, user2_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, user1_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 5, user1_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 6, user2_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 7, user2_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 8, user1_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 9, (int)limit);
    
    size_t rows = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW) rows++;
    sqlite3_reset(stmt);
    
    if (rows == 0) { sqlite3_finalize(stmt); return 0; }
    
    Tinyweb__Message** messages = calloc(rows, sizeof(Tinyweb__Message*));
    if (!messages) { sqlite3_finalize(stmt); return -1; }
    
    size_t idx = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW && idx < rows) {
        messages[idx] = reconstruct_message_from_db(
            sqlite3_column_int64(stmt, 0), (uint32_t)sqlite3_column_int(stmt, 1),
            (uint64_t)sqlite3_column_int64(stmt, 2),
            sqlite3_column_blob(stmt, 3), sqlite3_column_bytes(stmt, 3),
            sqlite3_column_blob(stmt, 4), sqlite3_column_bytes(stmt, 4),
            sqlite3_column_blob(stmt, 5), sqlite3_column_bytes(stmt, 5),
            sqlite3_column_blob(stmt, 6), sqlite3_column_bytes(stmt, 6),
            sqlite3_column_blob(stmt, 7), sqlite3_column_bytes(stmt, 7),
            sqlite3_column_blob(stmt, 8), sqlite3_column_bytes(stmt, 8),
            sqlite3_column_blob(stmt, 9), sqlite3_column_bytes(stmt, 9),
            db);
        if (messages[idx]) idx++;
    }
    sqlite3_finalize(stmt);
    *out = messages; *count = idx;
    return 0;
}

int message_store_fetch_conversations(const unsigned char user_pubkey[PUBKEY_SIZE],
                                      uint32_t limit,
                                      Tinyweb__ConversationList** out) {
    if (!user_pubkey || !out || !db_is_initialized()) return -1;
    *out = NULL;
    sqlite3* db = db_get_handle(); if (!db) return -1;

    // Optimized query using subquery with LIMIT to find unique partners quickly
    const char* sql =
        "SELECT partner, MAX(timestamp) as last_ts FROM ("
        "  SELECT * FROM (SELECT recipient_pubkey as partner, timestamp FROM user_messages WHERE sender_pubkey = ? ORDER BY timestamp DESC LIMIT 1000)"
        "  UNION ALL"
        "  SELECT * FROM (SELECT sender_pubkey as partner, timestamp FROM user_messages WHERE recipient_pubkey = ? ORDER BY timestamp DESC LIMIT 1000)"
        "  UNION ALL"
        "  SELECT * FROM (SELECT sender_pubkey as partner, timestamp FROM user_messages WHERE id IN (SELECT message_id FROM message_recipients WHERE recipient_pubkey = ?) ORDER BY timestamp DESC LIMIT 1000)"
        ") GROUP BY partner ORDER BY last_ts DESC LIMIT ?;";

    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        logger_error("message_store", "fetch_conversations: failed to prepare: %s", sqlite3_errmsg(db));
        return -1;
    }

    sqlite3_bind_blob(stmt, 1, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 2, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 3, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 4, (int)limit);

    size_t count = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW) count++;
    sqlite3_reset(stmt);

    Tinyweb__ConversationList* list = calloc(1, sizeof(Tinyweb__ConversationList));
    if (!list) { sqlite3_finalize(stmt); return -1; }
    tinyweb__conversation_list__init(list);

    if (count > 0) {
        list->n_conversations = count;
        list->conversations = calloc(count, sizeof(Tinyweb__ConversationSummary*));
        list->total_count = (uint32_t)count;

        size_t idx = 0;
        while (sqlite3_step(stmt) == SQLITE_ROW && idx < count) {
            Tinyweb__ConversationSummary* summary = calloc(1, sizeof(Tinyweb__ConversationSummary));
            if (summary) {
                tinyweb__conversation_summary__init(summary);
                const void* partner = sqlite3_column_blob(stmt, 0);
                summary->partner_pubkey.len = PUBKEY_SIZE;
                summary->partner_pubkey.data = malloc(PUBKEY_SIZE);
                if (summary->partner_pubkey.data) memcpy(summary->partner_pubkey.data, partner, PUBKEY_SIZE);
                summary->last_message_timestamp = (uint64_t)sqlite3_column_int64(stmt, 1);
                summary->unread_count = 0; // Future use
                list->conversations[idx++] = summary;
            }
        }
    }

    sqlite3_finalize(stmt);
    *out = list;
    return 0;
}

void message_store_free_messages(Tinyweb__Message** messages, size_t count) {
    if (!messages) return;
    for (size_t i = 0; i < count; i++) {
        if (messages[i]) tinyweb__message__free_unpacked(messages[i], NULL);
    }
    free(messages);
}

void message_store_free_conversation_list(Tinyweb__ConversationList* list) {
    if (!list) return;
    for (size_t i = 0; i < list->n_conversations; i++) {
        if (list->conversations[i]) {
            if (list->conversations[i]->partner_pubkey.data) free(list->conversations[i]->partner_pubkey.data);
            free(list->conversations[i]);
        }
    }
    if (list->conversations) free(list->conversations);
    free(list);
}
