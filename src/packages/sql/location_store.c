#include "location_store.h"
#include "schema.h"
#include "database_gossip.h"
#include "packages/utils/logger.h"
#include <sqlite3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/sha.h>

// Include protobuf headers when available (generated by CMake)
#include "client_request.pb-c.h"
#include "envelope.pb-c.h"

// SQL statements for location store
#define LOCATION_CREATE_TABLE \
    "CREATE TABLE IF NOT EXISTS location_updates (" \
    "id INTEGER PRIMARY KEY AUTOINCREMENT," \
    "user_pubkey BLOB NOT NULL," \
    "timestamp INTEGER NOT NULL," \
    "payload_nonce BLOB NOT NULL," \
    "ephemeral_pubkey BLOB NOT NULL," \
    "encrypted_payload BLOB NOT NULL," \
    "signature BLOB NOT NULL," \
    "expires_at INTEGER NOT NULL," \
    "created_at INTEGER NOT NULL DEFAULT (strftime('%s','now'))," \
    "is_envelope INTEGER NOT NULL DEFAULT 0" \
    ");"

#define LOCATION_CREATE_TABLE_KEYWRAPS \
    "CREATE TABLE IF NOT EXISTS location_keywraps (" \
    "location_id INTEGER NOT NULL," \
    "recipient_pubkey BLOB NOT NULL," \
    "key_nonce BLOB NOT NULL," \
    "wrapped_key BLOB NOT NULL," \
    "PRIMARY KEY (location_id, recipient_pubkey)," \
    "FOREIGN KEY (location_id) REFERENCES location_updates(id) ON DELETE CASCADE" \
    ");"

// Location store indexes
#define LOCATION_CREATE_INDEX_USER_TIMESTAMP \
    "CREATE INDEX IF NOT EXISTS idx_location_updates_user_timestamp ON location_updates(user_pubkey, timestamp DESC);"

#define LOCATION_CREATE_INDEX_EXPIRES \
    "CREATE INDEX IF NOT EXISTS idx_location_updates_expires ON location_updates(expires_at);"

#define LOCATION_CREATE_INDEX_KEYWRAPS_RECIPIENT \
    "CREATE INDEX IF NOT EXISTS idx_location_keywraps_recipient ON location_keywraps(recipient_pubkey);"

int location_store_init(void) {
    if (!db_is_initialized()) {
        logger_error("location_store", "database not initialized");
        return -1;
    }

    sqlite3* db = db_get_handle();
    if (!db) {
        logger_error("location_store", "failed to get database handle");
        return -1;
    }

    char* error_msg = NULL;
    int rc;

    // Create location_updates table
    rc = sqlite3_exec(db, LOCATION_CREATE_TABLE, NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("location_store", "failed to create location_updates table: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Create location_keywraps table
    rc = sqlite3_exec(db, LOCATION_CREATE_TABLE_KEYWRAPS, NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("location_store", "failed to create location_keywraps table: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Create indexes
    const char* index_statements[] = {
        LOCATION_CREATE_INDEX_USER_TIMESTAMP,
        LOCATION_CREATE_INDEX_EXPIRES,
        LOCATION_CREATE_INDEX_KEYWRAPS_RECIPIENT,
        NULL
    };

    for (int i = 0; index_statements[i] != NULL; ++i) {
        rc = sqlite3_exec(db, index_statements[i], NULL, NULL, &error_msg);
        if (rc != SQLITE_OK) {
            logger_error("location_store", "failed to create index: %s", error_msg);
            sqlite3_free(error_msg);
            return -1;
        }
    }

    logger_info("location_store", "location store schema initialized successfully");
    return 0;
}

// Compute SHA256 digest of serialized ClientRequest for deduplication
int location_store_compute_digest_client_request(const Tinyweb__ClientRequest* request, unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE]) {
    if (!request) return -1;
    
    // Serialize request to compute digest
    size_t len = tinyweb__client_request__get_packed_size((Tinyweb__ClientRequest*)request);
    unsigned char* buf = malloc(len);
    if (!buf) return -1;
    
    tinyweb__client_request__pack((Tinyweb__ClientRequest*)request, buf);
    SHA256(buf, len, digest);
    free(buf);
    
    return 0;
}

// Compute SHA256 digest of serialized Envelope for deduplication
int location_store_compute_digest_envelope(const Tinyweb__Envelope* envelope, unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE]) {
    if (!envelope) return -1;
    
    // Serialize envelope to compute digest
    size_t len = tinyweb__envelope__get_packed_size((Tinyweb__Envelope*)envelope);
    unsigned char* buf = malloc(len);
    if (!buf) return -1;
    
    tinyweb__envelope__pack((Tinyweb__Envelope*)envelope, buf);
    SHA256(buf, len, digest);
    free(buf);
    
    return 0;
}

int location_store_has_seen(const unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE], int* is_seen) {
    return gossip_store_has_seen(digest, is_seen);
}

int location_store_mark_seen(const unsigned char digest[GOSSIP_SEEN_DIGEST_SIZE], uint64_t expires_at) {
    return gossip_store_mark_seen(digest, expires_at);
}

int location_store_save(const Tinyweb__ClientRequest* request, uint64_t expires_at) {
    if (!db_is_initialized() || !request || !request->header) {
        logger_error("location_store", "location_store_save: invalid arguments");
        return -1;
    }
    
    sqlite3* db = db_get_handle();
    if (!db) {
        logger_error("location_store", "location_store_save: failed to get database handle");
        return -1;
    }
    
    const Tinyweb__ClientRequestHeader* hdr = request->header;
    
    // Validate required fields
    if (hdr->sender_pubkey.len != PUBKEY_SIZE) {
        logger_error("location_store", "location_store_save: invalid sender_pubkey length");
        return -1;
    }
    if (hdr->n_recipients_pubkey == 0) {
        logger_error("location_store", "location_store_save: no recipients");
        return -1;
    }
    if (!request->payload_nonce.data || request->payload_nonce.len != 24) {
        logger_error("location_store", "location_store_save: invalid payload_nonce");
        return -1;
    }
    if (!request->ephemeral_pubkey.data || request->ephemeral_pubkey.len != PUBKEY_SIZE) {
        logger_error("location_store", "location_store_save: invalid ephemeral_pubkey");
        return -1;
    }
    if (!request->payload_ciphertext.data || request->payload_ciphertext.len == 0) {
        logger_error("location_store", "location_store_save: invalid payload_ciphertext");
        return -1;
    }
    if (!request->signature.data || request->signature.len != 64) {
        logger_error("location_store", "location_store_save: invalid signature");
        return -1;
    }
    
    char* error_msg = NULL;
    int rc = sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("location_store", "failed to start transaction: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Insert into location_updates table
    const char* sql =
        "INSERT INTO location_updates(user_pubkey, timestamp, payload_nonce, ephemeral_pubkey, "
        "encrypted_payload, signature, expires_at, is_envelope) "
        "VALUES (?, ?, ?, ?, ?, ?, ?, 0);";
    sqlite3_stmt* stmt = NULL;
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("location_store", "location_store_save: failed to prepare statement: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    sqlite3_bind_blob(stmt, 1, hdr->sender_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, (sqlite3_int64)hdr->timestamp);
    sqlite3_bind_blob(stmt, 3, request->payload_nonce.data, 24, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, request->ephemeral_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 5, request->payload_ciphertext.data, (int)request->payload_ciphertext.len, SQLITE_TRANSIENT);
    sqlite3_bind_blob(stmt, 6, request->signature.data, 64, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, (sqlite3_int64)expires_at);
    
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    if (rc != SQLITE_DONE) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("location_store", "location_store_save: failed to insert location update: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    int64_t location_id = sqlite3_last_insert_rowid(db);
    logger_info("location_store", "location_store_save: inserted location update with id=%lld", (long long)location_id);
    
    // Insert keywraps into junction table
    if (request->n_keywraps > 0) {
        const char* keywrap_sql =
            "INSERT INTO location_keywraps(location_id, recipient_pubkey, key_nonce, wrapped_key) "
            "VALUES (?, ?, ?, ?);";
        
        sqlite3_stmt* keywrap_stmt = NULL;
        if (sqlite3_prepare_v2(db, keywrap_sql, -1, &keywrap_stmt, NULL) != SQLITE_OK) {
            logger_error("location_store", "location_store_save: failed to prepare keywrap statement: %s", sqlite3_errmsg(db));
            sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
            return -1;
        }

        for (size_t i = 0; i < request->n_keywraps; ++i) {
            const Tinyweb__ClientRequestKeyWrap* wrap = request->keywraps[i];
            if (!wrap) {
                logger_error("location_store", "location_store_save: keywrap %zu is NULL", i);
                continue;
            }
            if (wrap->recipient_pubkey.len != PUBKEY_SIZE) {
                logger_error("location_store", "location_store_save: keywrap %zu has invalid recipient_pubkey length: %zu", i, wrap->recipient_pubkey.len);
                continue;
            }
            
            sqlite3_reset(keywrap_stmt);
            sqlite3_bind_int64(keywrap_stmt, 1, location_id);
            sqlite3_bind_blob(keywrap_stmt, 2, wrap->recipient_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
            sqlite3_bind_blob(keywrap_stmt, 3, wrap->key_nonce.data, 24, SQLITE_STATIC);
            sqlite3_bind_blob(keywrap_stmt, 4, wrap->wrapped_key.data, (int)wrap->wrapped_key.len, SQLITE_STATIC);
            
            rc = sqlite3_step(keywrap_stmt);
            if (rc != SQLITE_DONE) {
                logger_error("location_store", "location_store_save: failed to insert keywrap %zu: %s (rc=%d)", i, sqlite3_errmsg(db), rc);
                sqlite3_finalize(keywrap_stmt);
                sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
                return -1;
            }
            logger_info("location_store", "location_store_save: inserted keywrap %zu for location_id=%lld", i, (long long)location_id);
        }
        sqlite3_finalize(keywrap_stmt);
    } else {
        logger_info("location_store", "location_store_save: no keywraps to insert (n_keywraps=%zu)", request->n_keywraps);
    }
    
    char* commit_error = NULL;
    int commit_rc = sqlite3_exec(db, "COMMIT;", NULL, NULL, &commit_error);
    if (commit_rc != SQLITE_OK) {
        logger_error("location_store", "location_store_save: failed to commit transaction: %s", commit_error ? commit_error : "unknown error");
        if (commit_error) sqlite3_free(commit_error);
        return -1;
    }
    logger_info("location_store", "location_store_save: transaction committed successfully");
    return 0;
}

int location_store_save_envelope(const Tinyweb__Envelope* envelope, uint64_t expires_at) {
    if (!db_is_initialized() || !envelope || !envelope->header) {
        logger_error("location_store", "location_store_save_envelope: invalid arguments");
        return -1;
    }
    
    sqlite3* db = db_get_handle();
    if (!db) {
        logger_error("location_store", "location_store_save_envelope: failed to get database handle");
        return -1;
    }
    
    const Tinyweb__EnvelopeHeader* hdr = envelope->header;
    
    // Validate required fields
    if (hdr->sender_pubkey.len != PUBKEY_SIZE) {
        logger_error("location_store", "location_store_save_envelope: invalid sender_pubkey length");
        return -1;
    }
    if (!envelope->payload_nonce.data || envelope->payload_nonce.len != 24) {
        logger_error("location_store", "location_store_save_envelope: invalid payload_nonce");
        return -1;
    }
    if (!envelope->ephemeral_pubkey.data || envelope->ephemeral_pubkey.len != PUBKEY_SIZE) {
        logger_error("location_store", "location_store_save_envelope: invalid ephemeral_pubkey");
        return -1;
    }
    if (!envelope->payload_ciphertext.data || envelope->payload_ciphertext.len == 0) {
        logger_error("location_store", "location_store_save_envelope: invalid payload_ciphertext");
        return -1;
    }
    if (!envelope->signature.data || envelope->signature.len != 64) {
        logger_error("location_store", "location_store_save_envelope: invalid signature");
        return -1;
    }
    
    char* error_msg = NULL;
    int rc = sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, &error_msg);
    if (rc != SQLITE_OK) {
        logger_error("location_store", "failed to start transaction: %s", error_msg);
        sqlite3_free(error_msg);
        return -1;
    }

    // Insert into location_updates table
    const char* sql =
        "INSERT INTO location_updates(user_pubkey, timestamp, payload_nonce, ephemeral_pubkey, "
        "encrypted_payload, signature, expires_at, is_envelope) "
        "VALUES (?, ?, ?, ?, ?, ?, ?, 1);";
    sqlite3_stmt* stmt = NULL;
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("location_store", "location_store_save_envelope: failed to prepare statement: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    sqlite3_bind_blob(stmt, 1, hdr->sender_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, (sqlite3_int64)hdr->timestamp);
    sqlite3_bind_blob(stmt, 3, envelope->payload_nonce.data, 24, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, envelope->ephemeral_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 5, envelope->payload_ciphertext.data, (int)envelope->payload_ciphertext.len, SQLITE_TRANSIENT);
    sqlite3_bind_blob(stmt, 6, envelope->signature.data, 64, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, (sqlite3_int64)expires_at);
    
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    if (rc != SQLITE_DONE) {
        sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
        logger_error("location_store", "location_store_save_envelope: failed to insert location update: %s", sqlite3_errmsg(db));
        return -1;
    }
    
    int64_t location_id = sqlite3_last_insert_rowid(db);
    
    // Insert keywraps into junction table
    if (envelope->n_keywraps > 0) {
        const char* keywrap_sql =
            "INSERT INTO location_keywraps(location_id, recipient_pubkey, key_nonce, wrapped_key) "
            "VALUES (?, ?, ?, ?);";
        
        sqlite3_stmt* keywrap_stmt = NULL;
        if (sqlite3_prepare_v2(db, keywrap_sql, -1, &keywrap_stmt, NULL) != SQLITE_OK) {
            sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
            return -1;
        }

        for (size_t i = 0; i < envelope->n_keywraps; ++i) {
            const Tinyweb__RecipientKeyWrap* wrap = envelope->keywraps[i];
            if (!wrap || wrap->recipient_pubkey.len != PUBKEY_SIZE) continue;
            
            sqlite3_reset(keywrap_stmt);
            sqlite3_bind_int64(keywrap_stmt, 1, location_id);
            sqlite3_bind_blob(keywrap_stmt, 2, wrap->recipient_pubkey.data, PUBKEY_SIZE, SQLITE_STATIC);
            sqlite3_bind_blob(keywrap_stmt, 3, wrap->key_nonce.data, 24, SQLITE_STATIC);
            sqlite3_bind_blob(keywrap_stmt, 4, wrap->wrapped_key.data, (int)wrap->wrapped_key.len, SQLITE_STATIC);
            
            rc = sqlite3_step(keywrap_stmt);
            if (rc != SQLITE_DONE) {
                logger_error("location_store", "location_store_save_envelope: failed to insert keywrap %zu: %s", i, sqlite3_errmsg(db));
                sqlite3_finalize(keywrap_stmt);
                sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
                return -1;
            }
        }
        sqlite3_finalize(keywrap_stmt);
    }
    
    char* commit_error = NULL;
    int commit_rc = sqlite3_exec(db, "COMMIT;", NULL, NULL, &commit_error);
    if (commit_rc != SQLITE_OK) {
        logger_error("location_store", "location_store_save_envelope: failed to commit transaction: %s", commit_error ? commit_error : "unknown error");
        if (commit_error) sqlite3_free(commit_error);
        return -1;
    }
    return 0;
}

// Helper function to reconstruct ClientRequest from database
static Tinyweb__ClientRequest* reconstruct_client_request_from_db(
    int64_t id,
    const unsigned char* user_pubkey, size_t user_pubkey_len,
    uint64_t timestamp,
    const unsigned char* payload_nonce, size_t payload_nonce_len,
    const unsigned char* ephemeral_pubkey, size_t ephemeral_pubkey_len,
    const unsigned char* encrypted_payload, size_t encrypted_payload_len,
    const unsigned char* signature, size_t signature_len,
    sqlite3* db) {
    
    if (user_pubkey_len != PUBKEY_SIZE || payload_nonce_len != 24 || 
        ephemeral_pubkey_len != PUBKEY_SIZE || signature_len != 64) {
        return NULL;
    }
    
    Tinyweb__ClientRequest* req = calloc(1, sizeof(Tinyweb__ClientRequest));
    if (!req) return NULL;
    tinyweb__client_request__init(req);
    
    Tinyweb__ClientRequestHeader* hdr = calloc(1, sizeof(Tinyweb__ClientRequestHeader));
    if (!hdr) {
        free(req);
        return NULL;
    }
    tinyweb__client_request_header__init(hdr);
    req->header = hdr;
    
    hdr->version = 1;  // Default version
    hdr->content_type = TINYWEB__CONTENT_TYPE__CONTENT_LOCATION_UPDATE;
    hdr->schema_version = 1;  // Default schema version
    hdr->timestamp = timestamp;
    
    hdr->sender_pubkey.len = PUBKEY_SIZE;
    hdr->sender_pubkey.data = malloc(PUBKEY_SIZE);
    if (!hdr->sender_pubkey.data) {
        free(hdr);
        free(req);
        return NULL;
    }
    memcpy(hdr->sender_pubkey.data, user_pubkey, PUBKEY_SIZE);
    
    // Fetch recipients and keywraps from junction table
    const char* keywrap_sql = 
        "SELECT recipient_pubkey, key_nonce, wrapped_key FROM location_keywraps "
        "WHERE location_id = ?;";
    sqlite3_stmt* keywrap_stmt = NULL;
    int rc = sqlite3_prepare_v2(db, keywrap_sql, -1, &keywrap_stmt, NULL);
    
    if (rc == SQLITE_OK) {
        sqlite3_bind_int64(keywrap_stmt, 1, id);
        
        size_t count = 0;
        while (sqlite3_step(keywrap_stmt) == SQLITE_ROW) count++;
        sqlite3_reset(keywrap_stmt);
        
        if (count > 0) {
            hdr->n_recipients_pubkey = count;
            hdr->recipients_pubkey = calloc(count, sizeof(ProtobufCBinaryData));
            req->n_keywraps = count;
            req->keywraps = calloc(count, sizeof(Tinyweb__ClientRequestKeyWrap*));
            
            if (!hdr->recipients_pubkey || !req->keywraps) {
                sqlite3_finalize(keywrap_stmt);
                tinyweb__client_request__free_unpacked(req, NULL);
                return NULL;
            }
            
            size_t idx = 0;
            while (sqlite3_step(keywrap_stmt) == SQLITE_ROW && idx < count) {
                const void* rec_pk = sqlite3_column_blob(keywrap_stmt, 0);
                hdr->recipients_pubkey[idx].len = PUBKEY_SIZE;
                hdr->recipients_pubkey[idx].data = malloc(PUBKEY_SIZE);
                if (!hdr->recipients_pubkey[idx].data) {
                    sqlite3_finalize(keywrap_stmt);
                    tinyweb__client_request__free_unpacked(req, NULL);
                    return NULL;
                }
                memcpy(hdr->recipients_pubkey[idx].data, rec_pk, PUBKEY_SIZE);
                
                Tinyweb__ClientRequestKeyWrap* wrap = calloc(1, sizeof(Tinyweb__ClientRequestKeyWrap));
                if (wrap) {
                    tinyweb__client_request_key_wrap__init(wrap);
                    wrap->recipient_pubkey.len = PUBKEY_SIZE;
                    wrap->recipient_pubkey.data = malloc(PUBKEY_SIZE);
                    const void* nonce = sqlite3_column_blob(keywrap_stmt, 1);
                    wrap->key_nonce.len = 24;
                    wrap->key_nonce.data = malloc(24);
                    const void* key = sqlite3_column_blob(keywrap_stmt, 2);
                    int klen = sqlite3_column_bytes(keywrap_stmt, 2);
                    wrap->wrapped_key.len = klen;
                    wrap->wrapped_key.data = malloc(klen);
                    
                    if (!wrap->recipient_pubkey.data || !wrap->key_nonce.data || !wrap->wrapped_key.data) {
                        if (wrap->recipient_pubkey.data) free(wrap->recipient_pubkey.data);
                        if (wrap->key_nonce.data) free(wrap->key_nonce.data);
                        if (wrap->wrapped_key.data) free(wrap->wrapped_key.data);
                        free(wrap);
                        sqlite3_finalize(keywrap_stmt);
                        tinyweb__client_request__free_unpacked(req, NULL);
                        return NULL;
                    }
                    
                    memcpy(wrap->recipient_pubkey.data, rec_pk, PUBKEY_SIZE);
                    memcpy(wrap->key_nonce.data, nonce, 24);
                    memcpy(wrap->wrapped_key.data, key, klen);
                    req->keywraps[idx] = wrap;
                } else {
                    sqlite3_finalize(keywrap_stmt);
                    tinyweb__client_request__free_unpacked(req, NULL);
                    return NULL;
                }
                idx++;
            }
        }
        sqlite3_finalize(keywrap_stmt);
    }
    
    req->payload_nonce.len = 24;
    req->payload_nonce.data = malloc(24);
    if (!req->payload_nonce.data) {
        tinyweb__client_request__free_unpacked(req, NULL);
        return NULL;
    }
    memcpy(req->payload_nonce.data, payload_nonce, 24);
    
    req->ephemeral_pubkey.len = PUBKEY_SIZE;
    req->ephemeral_pubkey.data = malloc(PUBKEY_SIZE);
    if (!req->ephemeral_pubkey.data) {
        tinyweb__client_request__free_unpacked(req, NULL);
        return NULL;
    }
    memcpy(req->ephemeral_pubkey.data, ephemeral_pubkey, PUBKEY_SIZE);
    
    req->payload_ciphertext.len = encrypted_payload_len;
    req->payload_ciphertext.data = malloc(encrypted_payload_len);
    if (!req->payload_ciphertext.data) {
        tinyweb__client_request__free_unpacked(req, NULL);
        return NULL;
    }
    memcpy(req->payload_ciphertext.data, encrypted_payload, encrypted_payload_len);
    
    req->signature.len = 64;
    req->signature.data = malloc(64);
    if (!req->signature.data) {
        tinyweb__client_request__free_unpacked(req, NULL);
        return NULL;
    }
    memcpy(req->signature.data, signature, 64);
    
    return req;
}

// Helper function to reconstruct Envelope from database
static Tinyweb__Envelope* reconstruct_envelope_from_db(
    int64_t id,
    const unsigned char* user_pubkey, size_t user_pubkey_len,
    uint64_t timestamp,
    const unsigned char* payload_nonce, size_t payload_nonce_len,
    const unsigned char* ephemeral_pubkey, size_t ephemeral_pubkey_len,
    const unsigned char* encrypted_payload, size_t encrypted_payload_len,
    const unsigned char* signature, size_t signature_len,
    sqlite3* db) {
    
    if (user_pubkey_len != PUBKEY_SIZE || payload_nonce_len != 24 || 
        ephemeral_pubkey_len != PUBKEY_SIZE || signature_len != 64) {
        return NULL;
    }
    
    Tinyweb__Envelope* env = calloc(1, sizeof(Tinyweb__Envelope));
    if (!env) return NULL;
    tinyweb__envelope__init(env);
    
    Tinyweb__EnvelopeHeader* hdr = calloc(1, sizeof(Tinyweb__EnvelopeHeader));
    if (!hdr) {
        free(env);
        return NULL;
    }
    tinyweb__envelope_header__init(hdr);
    env->header = hdr;
    
    hdr->version = 1;  // Default version
    hdr->content_type = TINYWEB__CONTENT_TYPE__CONTENT_LOCATION_UPDATE;
    hdr->schema_version = 1;  // Default schema version
    hdr->timestamp = timestamp;
    
    hdr->sender_pubkey.len = PUBKEY_SIZE;
    hdr->sender_pubkey.data = malloc(PUBKEY_SIZE);
    if (!hdr->sender_pubkey.data) {
        free(hdr);
        free(env);
        return NULL;
    }
    memcpy(hdr->sender_pubkey.data, user_pubkey, PUBKEY_SIZE);
    
    // Fetch recipients and keywraps from junction table
    const char* keywrap_sql = 
        "SELECT recipient_pubkey, key_nonce, wrapped_key FROM location_keywraps "
        "WHERE location_id = ?;";
    sqlite3_stmt* keywrap_stmt = NULL;
    int rc = sqlite3_prepare_v2(db, keywrap_sql, -1, &keywrap_stmt, NULL);
    
    if (rc == SQLITE_OK) {
        sqlite3_bind_int64(keywrap_stmt, 1, id);
        
        size_t count = 0;
        while (sqlite3_step(keywrap_stmt) == SQLITE_ROW) count++;
        sqlite3_reset(keywrap_stmt);
        
        if (count > 0) {
            hdr->n_recipients_pubkey = count;
            hdr->recipients_pubkey = calloc(count, sizeof(ProtobufCBinaryData));
            env->n_keywraps = count;
            env->keywraps = calloc(count, sizeof(Tinyweb__RecipientKeyWrap*));
            
            if (!hdr->recipients_pubkey || !env->keywraps) {
                sqlite3_finalize(keywrap_stmt);
                tinyweb__envelope__free_unpacked(env, NULL);
                return NULL;
            }
            
            size_t idx = 0;
            while (sqlite3_step(keywrap_stmt) == SQLITE_ROW && idx < count) {
                const void* rec_pk = sqlite3_column_blob(keywrap_stmt, 0);
                hdr->recipients_pubkey[idx].len = PUBKEY_SIZE;
                hdr->recipients_pubkey[idx].data = malloc(PUBKEY_SIZE);
                if (!hdr->recipients_pubkey[idx].data) {
                    sqlite3_finalize(keywrap_stmt);
                    tinyweb__envelope__free_unpacked(env, NULL);
                    return NULL;
                }
                memcpy(hdr->recipients_pubkey[idx].data, rec_pk, PUBKEY_SIZE);
                
                Tinyweb__RecipientKeyWrap* wrap = calloc(1, sizeof(Tinyweb__RecipientKeyWrap));
                if (wrap) {
                    tinyweb__recipient_key_wrap__init(wrap);
                    wrap->recipient_pubkey.len = PUBKEY_SIZE;
                    wrap->recipient_pubkey.data = malloc(PUBKEY_SIZE);
                    const void* nonce = sqlite3_column_blob(keywrap_stmt, 1);
                    wrap->key_nonce.len = 24;
                    wrap->key_nonce.data = malloc(24);
                    const void* key = sqlite3_column_blob(keywrap_stmt, 2);
                    int klen = sqlite3_column_bytes(keywrap_stmt, 2);
                    wrap->wrapped_key.len = klen;
                    wrap->wrapped_key.data = malloc(klen);
                    
                    if (!wrap->recipient_pubkey.data || !wrap->key_nonce.data || !wrap->wrapped_key.data) {
                        if (wrap->recipient_pubkey.data) free(wrap->recipient_pubkey.data);
                        if (wrap->key_nonce.data) free(wrap->key_nonce.data);
                        if (wrap->wrapped_key.data) free(wrap->wrapped_key.data);
                        free(wrap);
                        sqlite3_finalize(keywrap_stmt);
                        tinyweb__envelope__free_unpacked(env, NULL);
                        return NULL;
                    }
                    
                    memcpy(wrap->recipient_pubkey.data, rec_pk, PUBKEY_SIZE);
                    memcpy(wrap->key_nonce.data, nonce, 24);
                    memcpy(wrap->wrapped_key.data, key, klen);
                    env->keywraps[idx] = wrap;
                } else {
                    sqlite3_finalize(keywrap_stmt);
                    tinyweb__envelope__free_unpacked(env, NULL);
                    return NULL;
                }
                idx++;
            }
        }
        sqlite3_finalize(keywrap_stmt);
    }
    
    env->payload_nonce.len = 24;
    env->payload_nonce.data = malloc(24);
    if (!env->payload_nonce.data) {
        tinyweb__envelope__free_unpacked(env, NULL);
        return NULL;
    }
    memcpy(env->payload_nonce.data, payload_nonce, 24);
    
    env->ephemeral_pubkey.len = PUBKEY_SIZE;
    env->ephemeral_pubkey.data = malloc(PUBKEY_SIZE);
    if (!env->ephemeral_pubkey.data) {
        tinyweb__envelope__free_unpacked(env, NULL);
        return NULL;
    }
    memcpy(env->ephemeral_pubkey.data, ephemeral_pubkey, PUBKEY_SIZE);
    
    env->payload_ciphertext.len = encrypted_payload_len;
    env->payload_ciphertext.data = malloc(encrypted_payload_len);
    if (!env->payload_ciphertext.data) {
        tinyweb__envelope__free_unpacked(env, NULL);
        return NULL;
    }
    memcpy(env->payload_ciphertext.data, encrypted_payload, encrypted_payload_len);
    
    env->signature.len = 64;
    env->signature.data = malloc(64);
    if (!env->signature.data) {
        tinyweb__envelope__free_unpacked(env, NULL);
        return NULL;
    }
    memcpy(env->signature.data, signature, 64);
    
    return env;
}

int location_store_get_latest(const unsigned char user_pubkey[PUBKEY_SIZE],
                              unsigned char** out_data,
                              size_t* out_len,
                              int* is_envelope) {
    if (!user_pubkey || !out_data || !out_len || !is_envelope || !db_is_initialized()) {
        return -1;
    }
    
    *out_data = NULL;
    *out_len = 0;
    *is_envelope = 0;
    
    sqlite3* db = db_get_handle();
    if (!db) return -1;
    
    const char* sql =
        "SELECT id, timestamp, payload_nonce, ephemeral_pubkey, encrypted_payload, signature, is_envelope "
        "FROM location_updates "
        "WHERE user_pubkey = ? "
        "ORDER BY timestamp DESC LIMIT 1;";
    
    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        return -1;
    }
    
    sqlite3_bind_blob(stmt, 1, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    
    if (sqlite3_step(stmt) == SQLITE_ROW) {
        int64_t id = sqlite3_column_int64(stmt, 0);
        uint64_t timestamp = sqlite3_column_int64(stmt, 1);
        const void* payload_nonce = sqlite3_column_blob(stmt, 2);
        int payload_nonce_len = sqlite3_column_bytes(stmt, 2);
        const void* ephemeral_pubkey = sqlite3_column_blob(stmt, 3);
        int ephemeral_pubkey_len = sqlite3_column_bytes(stmt, 3);
        const void* encrypted_payload = sqlite3_column_blob(stmt, 4);
        int encrypted_payload_len = sqlite3_column_bytes(stmt, 4);
        const void* signature = sqlite3_column_blob(stmt, 5);
        int signature_len = sqlite3_column_bytes(stmt, 5);
        int env_flag = sqlite3_column_int(stmt, 6);
        
        *is_envelope = env_flag;
        
        // Reconstruct the structure
        if (env_flag) {
            Tinyweb__Envelope* env = reconstruct_envelope_from_db(
                id, user_pubkey, PUBKEY_SIZE, timestamp,
                payload_nonce, payload_nonce_len,
                ephemeral_pubkey, ephemeral_pubkey_len,
                encrypted_payload, encrypted_payload_len,
                signature, signature_len,
                db);
            if (env) {
                size_t len = tinyweb__envelope__get_packed_size(env);
                unsigned char* buf = malloc(len);
                if (buf) {
                    tinyweb__envelope__pack(env, buf);
                    *out_data = buf;
                    *out_len = len;
                }
                tinyweb__envelope__free_unpacked(env, NULL);
            }
        } else {
            Tinyweb__ClientRequest* req = reconstruct_client_request_from_db(
                id, user_pubkey, PUBKEY_SIZE, timestamp,
                payload_nonce, payload_nonce_len,
                ephemeral_pubkey, ephemeral_pubkey_len,
                encrypted_payload, encrypted_payload_len,
                signature, signature_len,
                db);
            if (req) {
                size_t len = tinyweb__client_request__get_packed_size(req);
                unsigned char* buf = malloc(len);
                if (buf) {
                    tinyweb__client_request__pack(req, buf);
                    *out_data = buf;
                    *out_len = len;
                }
                tinyweb__client_request__free_unpacked(req, NULL);
            }
        }
    }
    
    sqlite3_finalize(stmt);
    return (*out_data != NULL) ? 0 : 1;  // 0 = success, 1 = not found, -1 = error
}

int location_store_get_history(const unsigned char user_pubkey[PUBKEY_SIZE],
                               uint32_t limit,
                               uint32_t offset,
                               unsigned char*** out_data_array,
                               size_t** out_len_array,
                               size_t* count,
                               int** is_envelope_array) {
    if (!user_pubkey || !out_data_array || !out_len_array || !count || !is_envelope_array || !db_is_initialized()) {
        return -1;
    }
    
    *out_data_array = NULL;
    *out_len_array = NULL;
    *count = 0;
    *is_envelope_array = NULL;
    
    sqlite3* db = db_get_handle();
    if (!db) return -1;
    
    const char* sql =
        "SELECT id, timestamp, payload_nonce, ephemeral_pubkey, encrypted_payload, signature, is_envelope "
        "FROM location_updates "
        "WHERE user_pubkey = ? "
        "ORDER BY timestamp DESC LIMIT ? OFFSET ?;";
    
    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        return -1;
    }
    
    sqlite3_bind_blob(stmt, 1, user_pubkey, PUBKEY_SIZE, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 2, (int)limit);
    sqlite3_bind_int(stmt, 3, (int)offset);
    
    // First pass: count rows
    size_t rows = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW) rows++;
    sqlite3_reset(stmt);
    
    if (rows == 0) {
        sqlite3_finalize(stmt);
        return 0;  // No results, but not an error
    }
    
    unsigned char** data_array = calloc(rows, sizeof(unsigned char*));
    size_t* len_array = calloc(rows, sizeof(size_t));
    int* env_array = calloc(rows, sizeof(int));
    
    if (!data_array || !len_array || !env_array) {
        if (data_array) free(data_array);
        if (len_array) free(len_array);
        if (env_array) free(env_array);
        sqlite3_finalize(stmt);
        return -1;
    }
    
    size_t idx = 0;
    while (sqlite3_step(stmt) == SQLITE_ROW && idx < rows) {
        int64_t id = sqlite3_column_int64(stmt, 0);
        uint64_t timestamp = sqlite3_column_int64(stmt, 1);
        const void* payload_nonce = sqlite3_column_blob(stmt, 2);
        int payload_nonce_len = sqlite3_column_bytes(stmt, 2);
        const void* ephemeral_pubkey = sqlite3_column_blob(stmt, 3);
        int ephemeral_pubkey_len = sqlite3_column_bytes(stmt, 3);
        const void* encrypted_payload = sqlite3_column_blob(stmt, 4);
        int encrypted_payload_len = sqlite3_column_bytes(stmt, 4);
        const void* signature = sqlite3_column_blob(stmt, 5);
        int signature_len = sqlite3_column_bytes(stmt, 5);
        int env_flag = sqlite3_column_int(stmt, 6);
        
        env_array[idx] = env_flag;
        
        // Reconstruct the structure
        if (env_flag) {
            Tinyweb__Envelope* env = reconstruct_envelope_from_db(
                id, user_pubkey, PUBKEY_SIZE, timestamp,
                payload_nonce, payload_nonce_len,
                ephemeral_pubkey, ephemeral_pubkey_len,
                encrypted_payload, encrypted_payload_len,
                signature, signature_len,
                db);
            if (env) {
                size_t len = tinyweb__envelope__get_packed_size(env);
                unsigned char* buf = malloc(len);
                if (buf) {
                    tinyweb__envelope__pack(env, buf);
                    data_array[idx] = buf;
                    len_array[idx] = len;
                }
                tinyweb__envelope__free_unpacked(env, NULL);
            }
        } else {
            Tinyweb__ClientRequest* req = reconstruct_client_request_from_db(
                id, user_pubkey, PUBKEY_SIZE, timestamp,
                payload_nonce, payload_nonce_len,
                ephemeral_pubkey, ephemeral_pubkey_len,
                encrypted_payload, encrypted_payload_len,
                signature, signature_len,
                db);
            if (req) {
                size_t len = tinyweb__client_request__get_packed_size(req);
                unsigned char* buf = malloc(len);
                if (buf) {
                    tinyweb__client_request__pack(req, buf);
                    data_array[idx] = buf;
                    len_array[idx] = len;
                }
                tinyweb__client_request__free_unpacked(req, NULL);
            }
        }
        idx++;
    }
    
    sqlite3_finalize(stmt);
    
    *out_data_array = data_array;
    *out_len_array = len_array;
    *count = idx;
    *is_envelope_array = env_array;
    
    return 0;
}

void location_store_free_data(unsigned char* data) {
    if (data) {
        free(data);
    }
}

void location_store_free_data_array(unsigned char** data_array, size_t* len_array, size_t count, int* is_envelope_array) {
    if (!data_array) return;
    
    for (size_t i = 0; i < count; i++) {
        if (data_array[i]) {
            free(data_array[i]);
        }
    }
    
    free(data_array);
    if (len_array) free(len_array);
    if (is_envelope_array) free(is_envelope_array);
}

