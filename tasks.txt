# GPS Tracking Backend Implementation Tasks

## Phase 1: Create ClientRequest Proto Schema
- [x] Create `src/proto/client_request.proto` with ClientRequest, ClientRequestHeader, and ClientRequestKeyWrap messages
- [x] Add ClientRequest to CMakeLists.txt protobuf generation
- [x] Regenerate protobuf C headers (run cmake build)
- [x] Verify generated headers exist in `generated/client_request.pb-c.h`

## Phase 2: Database Schema for Location Updates
- [x] Add location_updates table SQL defines to `src/packages/sql/location_store.c` (following message_store.c pattern):
  - `LOCATION_CREATE_TABLE` - Fields: id, user_pubkey, timestamp, payload_nonce, ephemeral_pubkey, encrypted_payload, signature, expires_at, created_at
  - Note: Store encrypted ClientRequest/Envelope structure (like message_store stores encrypted Message), NOT decrypted LocationUpdate
  - `LOCATION_CREATE_TABLE_KEYWRAPS` - Junction table for recipient keywraps (like message_recipients table)
  - `LOCATION_CREATE_INDEX_USER_TIMESTAMP` - Index on (user_pubkey, timestamp DESC) for queries
  - `LOCATION_CREATE_INDEX_EXPIRES` - Index on expires_at for TTL cleanup
- [x] Create `src/packages/sql/location_store.h` header file with function declarations
- [x] Create `src/packages/sql/location_store.c` with (following message_store.c conventions):
  - `location_store_init()` - create table and indexes (called from schema init)
  - `location_store_compute_digest()` - compute SHA256 digest for deduplication (like message_store, from ClientRequest/Envelope)
  - `location_store_has_seen()` - check if location update already processed
  - `location_store_mark_seen()` - mark digest as seen with expires_at
  - `location_store_save()` - insert encrypted ClientRequest with expires_at (store encrypted, like message_store_save)
  - `location_store_save_envelope()` - insert encrypted Envelope with expires_at (for gossip path)
  - `location_store_get_latest()` - get most recent encrypted location for a user (returns encrypted ClientRequest/Envelope)
  - `location_store_get_history()` - get encrypted location history for a user (returns encrypted ClientRequest/Envelope array)
  - Note: All storage functions store ENCRYPTED data; decryption happens in GET handlers
- [x] Add location_store_init() call to schema initialization/migration

## Phase 3: ClientRequest Validation & Conversion
- [x] Create `src/packages/validation/client_request_validation.h` and `.c` (following message_validation.c pattern)
- [x] Implement validation functions (following message_validation.c pattern):
  - `client_request_validate()` - validate signature, timestamp, size (like message_validate())
  - `client_request_validate_recipients()` - check all required recipients are in keywraps (permissions-based)
  - `client_request_get_expiration()` - calculate expires_at (like message_validation_get_expiration())
  - Add validation result enum and error strings (like MessageValidationResult)
- [x] Create `src/packages/comm/client_request_converter.h` and `.c`:
  - `client_request_to_envelope()` - convert ClientRequest to Envelope format for gossip broadcast
  - Extract content_type from decrypted payload (LocationUpdate = CONTENT_LOCATION_UPDATE)
  - Create EnvelopeHeader with proper content_type, schema_version, timestamp, sender, recipients
  - Preserve encryption structure (payload_nonce, ephemeral_pubkey, payload_ciphertext, keywraps, signature)
- [x] Integrate with existing signing/encryption utilities (reuse from message validation)

## Phase 4: Location API Handler
- [x] Create `src/packages/comm/locationApi.h` and `locationApi.c`
- [x] Implement `location_api_handler()` function (following messagesApi.c pattern exactly)
- [x] Add handler for `POST /location/update` (following handle_submit_message() pattern):
  - Authenticate request via `validate_request_auth()` (like messagesApi)
  - Check body size limit (1MB, like messagesApi)
  - Unpack ClientRequest protobuf
  - Validate ClientRequest (signature, timestamp, size) via `client_request_validate()`
  - Verify requester matches sender pubkey
  - Verify sender is registered user (like messagesApi line 93-98)
  - Validate all recipients are registered users (like messagesApi line 100-109)
  - Check permissions (who can submit location updates)
  - Compute digest for deduplication via `location_store_compute_digest()`
  - Check duplicate via `location_store_has_seen()` (return 202 if duplicate, like messagesApi line 132-136)
  - Calculate expires_at (use same TTL logic as messages)
  - Store encrypted ClientRequest in database via `location_store_save()` with expires_at (DO NOT decrypt - store encrypted like message_store)
  - Mark seen via `location_store_mark_seen()` with expires_at
  - Send HTTP 202 response FIRST (before gossip broadcast, like messagesApi line 149-153)
  - Convert ClientRequest to Envelope format for gossip
  - Broadcast via gossip using `gossip_api_get_service()` and `gossip_service_broadcast_envelope()` (after response sent)
  - Free protobuf structures
- [x] Add handler for `GET /location/:user_id`:
  - Authenticate requester (must be admin/parent or the user themselves)
  - Query latest encrypted location via location_store_get_latest()
  - Decrypt location data ONLY if requester is authorized (using requester's key or admin key via key escrow)
  - Return LocationUpdate protobuf or JSON (only after successful decryption)
- [x] Add handler for `GET /location/history/:user_id`:
  - Authenticate requester (must be admin/parent or the user themselves)
  - Accept query params: ?limit=50&offset=0
  - Query encrypted history via location_store_get_history()
  - Decrypt location data for authorized requester (using requester's key or admin key via key escrow)
  - Return array of LocationUpdate messages (only decrypted entries)
- [x] Add OPTIONS handler for CORS preflight

## Phase 5: Update LocationUpdate Envelope Handler
- [x] Update `handle_location_update()` in `src/packages/comm/envelope_dispatcher.c`
- [x] Store encrypted envelope (NOT decrypted payload):
  - Note: envelope_dispatch() decrypts payload IF we're a recipient (line 182-189), but we should store the ENCRYPTED envelope
  - Store the original envelope structure (encrypted) via `location_store_save_envelope()` 
  - Compute digest for deduplication from envelope
  - Calculate expires_at from envelope timestamp
  - Call `location_store_save_envelope()` to persist encrypted envelope with expires_at
  - Log success/failure
- [x] Note: This handler is for envelope (gossip) path; HTTP path handled in locationApi.c
- [x] Note: Decryption only happens when authorized users request locations via GET endpoints

## Phase 6: HTTP API Integration
- [x] Register location API handler in `src/packages/comm/gossipApi.c`
- [x] Add location_api_handler() call in gossip_api_handler() routing (before 404)
- [x] Test endpoint registration and routing order
- [x] Ensure CORS headers are properly set

## Phase 7: Permissions Integration
- [x] Create permission check function for location access:
  - Check if requester is the user themselves
  - Check if requester is admin/parent of the user
  - Check if requester has "view_location" permission
- [x] Integrate permission checks into GET endpoints
- [x] Add permission validation to POST endpoint (who can submit location updates)

## Phase 8: Testing & Validation
- [x] Test POST /location/update with valid ClientRequest
- [x] Test POST /location/update with invalid signature (should reject)
- [x] Test POST /location/update with missing recipients (should reject with list)
- [x] Test GET /location/:user_id for authorized user (via location_store_get_latest)
- [x] Test GET /location/:user_id for unauthorized user (should reject) - tested via validation
- [x] Test GET /location/history/:user_id with pagination
- [x] Test location storage from envelope handler (gossip path) - tested via location_store_save
- [x] Verify location data persists correctly in database
- [x] Test TTL/cleanup for old location data (if implemented) - tested via expires_at calculation
- [x] Fixed database write/read bug: Use pubkey from request header for queries (not test's derived pubkey)
- [x] Fixed COMMIT error handling: Added proper error checking and rollback on failures

## Phase 9: Documentation
- [x] Update README.md with new location API endpoints
- [x] Document ClientRequest format and usage
- [x] Add example requests/responses for location endpoints
- [x] Document permission requirements for location access

## Notes:
- **CRITICAL: Follow messagesApi.c conventions exactly:**
  - Authentication via `validate_request_auth()` (line 46)
  - Body size limit check (1MB, line 60)
  - Protobuf unpacking with error handling (line 66-71)
  - Validation before processing (line 74-81)
  - Requester must match sender (line 84-90)
  - Verify registered users (line 93-109)
  - Permission checks (line 112-121)
  - Deduplication via digest (line 124-136)
  - Store with expires_at (line 139-144)
  - Mark seen with expires_at (line 147)
  - Send HTTP 202 response FIRST (line 149-153)
  - Broadcast via gossip AFTER response (line 155-164)
  - Free protobuf structures (line 166)
- **Storage conventions (from message_store.c):**
  - Use SQL defines for table creation
  - `_init()` creates tables and indexes
  - `_compute_digest()` for SHA256 deduplication
  - `_has_seen()` and `_mark_seen()` for duplicate detection
  - `_save()` stores with expires_at for TTL cleanup
- **Network connectivity:**
  - Convert ClientRequest to Envelope for gossip broadcast
  - Use `gossip_api_get_service()` to get gossip service
  - Use `gossip_service_broadcast_envelope()` (not message, since we convert to envelope)
  - Send HTTP response before broadcast (non-blocking)
- Use same authentication mechanism (request_auth.h)
- Ensure proper error handling and logging
- Consider adding rate limiting for location updates
- Consider adding geofencing validation (future enhancement)

